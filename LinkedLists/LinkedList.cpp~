/*

Implementation file for singly LinkedList object

*/
#include "LinkedList.hpp"

//Default Constructor
temOBplate <class T>
LinkedList<T>::LinkedList() {
 head = nullptr;
 tail = nullptr;
 size = 0;
}

//Constructor 
template <class T>
LinkedList<T>::LinkedList(T val) {
  head = new ListNode(val);
  tail = head;
  size = 1;
}
dh
//destructor
template <class T>
LinkedList<T>::~LinkedList() {
  ListNode* ptr = head;
  while(ptr != nullptr){
    ListNode* garbage = ptr;
    ptr = ptr->next;
    delete garbage;
  }
}

//Copy constructor
/*template <class T>
LinkedList<T>::LinkedList(const LinkedList &obj) {

}

//overloaded assignment operator
template <class T>
LinkedList<T>& LinkedList<T>::operator=(const LinkedList &rhs) {

}*/

//Returns the size of LinkedList
template <class T>
int LinkedList<T>::size() const {
  return size;
}

//Returns True if list is empty
template <class T>
bool LinkedList<T>::isEmpty() const {
 if(head == nullptr){
    return true;
  }
  return false;
}

//Pushes a value at the given position (pos)
template <class T>
void LinkedList<T>::insert(int pos, T value) {

}

//Pushes value to the front of the LinkedList
template <class T>
void LinkedList<T>::pushFront(T value) {
	ListNode* temp = new ListNode(value, head);
	head = temp;
}

//Pushes a value to the back of LinkedList
template <class T>
void LinkedList<T>::pushBack(T value) {

}

//Removes the value, throws error if it is not there
template <class T>
void LinkedList<T>::remove(T value) {

}

//Reverse LinkedList
template <class T>
void LinkedList<T>::reverse() {

}

template class LinkedList<int>;


/*
      __       __
    .'  `'._.'`  '.
   |  .--;   ;--.  |
   |  (  /   \  )  |
    \  ;` /^\ `;  /
     :` .'._.'. `;
     '-`'.___.'`-'

*/
